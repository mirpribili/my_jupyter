{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "# Функции\n",
    "- - [Алгоритмы теория и практика Методы](http://localhost:8888/notebooks/jupyter/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F%20%D0%B8%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B.ipynb#):\n",
    "- - [Codewars](http://localhost:8888/notebooks/CodeWars.ipynb)\n",
    "- - [Справрчник Python](http://localhost:8888/notebooks/jupyter/200625_%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA.ipynb#):\n",
    "- [Функции](http://localhost:8888/notebooks/%D0%A4%D1%83%D0%BA%D1%86%D0%B8%D0%B8.ipynb)\n",
    "\n",
    "- - [Визуализатор](http://pythontutor.com/visualize.html#mode=edit)\n",
    "- - [py reg](https://pythex.org)\n",
    "- - - [py reg library](https://docs.python.org/3.5/library/re.html)\n",
    "- - - [py reg шпора](https://www.exlab.net/files/tools/sheets/regexp/regexp.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "\"\\nадачу эту можно решить разными способами. Но задумка авторов состояла в том, чтобы учащиеся сами нашли информацию о расширенной функциональности регулярных выражений.\\n\\nИдея состоит в том, чтобы создать конечный автомат(FSM) и преобразовать его в регулярное выражение.\\n\\nЯ разобрался так(весь тернистый путь познания приводить не буду, только основные моменты):\\n1. Построить конечный автомат.\\nНашел алгоритм как нарисовать конечный автомат делимости на 3. Рассчитал, нарисовал.\\nИсточник: https://itnan.ru/post.php?c=1&p=420817\\nчасть 1.Конечные автоматы\\n\\n2. Преобразовать КА в регулярное выражение.\\nНашел модуль greenery для Питона, скачал и импортировал. По нарисованному в виде графа КА ввел нужные данные в шаблон кода, запустил - получил РВ.\\nИсточник: https://fooobar.com/questions/1247901/convert-finite-state-machine-to-regular-expression\\nсм. ответ 'лучший инструмент, который я использовал, greenery. Это библиотека преобразования FSM/regex для python.'\\n\\n3. Написать код.\\nЭто самая простая часть)\\n\\nВсем успехов!\\n\""
      ]
     },
     "execution_count": 152,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(int('011', 2))\n",
    "'''\n",
    "адачу эту можно решить разными способами. Но задумка авторов состояла в том, чтобы учащиеся сами нашли информацию о расширенной функциональности регулярных выражений.\n",
    "\n",
    "Идея состоит в том, чтобы создать конечный автомат(FSM) и преобразовать его в регулярное выражение.\n",
    "\n",
    "Я разобрался так(весь тернистый путь познания приводить не буду, только основные моменты):\n",
    "1. Построить конечный автомат.\n",
    "Нашел алгоритм как нарисовать конечный автомат делимости на 3. Рассчитал, нарисовал.\n",
    "Источник: https://itnan.ru/post.php?c=1&p=420817\n",
    "часть 1.Конечные автоматы\n",
    "\n",
    "2. Преобразовать КА в регулярное выражение.\n",
    "Нашел модуль greenery для Питона, скачал и импортировал. По нарисованному в виде графа КА ввел нужные данные в шаблон кода, запустил - получил РВ.\n",
    "Источник: https://fooobar.com/questions/1247901/convert-finite-state-machine-to-regular-expression\n",
    "см. ответ 'лучший инструмент, который я использовал, greenery. Это библиотека преобразования FSM/regex для python.'\n",
    "\n",
    "3. Написать код.\n",
    "Это самая простая часть)\n",
    "\n",
    "Всем успехов!\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "atraction\n",
      "buz\n",
      "abv\n",
      "mewmewNnya\n",
      "aqb\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'\\n\\nВам дана последовательность строк.\\nВ каждой строке замените все вхождения нескольких одинаковых \\nбукв на одну букву.\\nБуквой считается символ из группы \\\\w.\\n\\nSample Input:\\n\\nattraction\\nbuzzzz\\n\\nSample Output:\\n\\natraction\\nbuz\\n\\n\\n'"
      ]
     },
     "execution_count": 145,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "import re\n",
    "import sys\n",
    "\n",
    "pattern = r\"((\\w)\\2+)\"\n",
    "\n",
    "def re_poisk(string):\n",
    "    match_obj = re.findall(pattern, string)\n",
    "    #print(match_obj)\n",
    "    \n",
    "    for i in match_obj:\n",
    "        #print(i)\n",
    "        try:\n",
    "            #print(string, '->', i[0], '=',    end=' ')\n",
    "            string = re.sub(\n",
    "                r\"\"+i[0], \n",
    "                i[0][0], \n",
    "                string.strip()\n",
    "            )\n",
    "        except:\n",
    "            pass\n",
    "    return string\n",
    " \n",
    "\n",
    "for line in sys.stdin:\n",
    "    string = line.strip()\n",
    "    print(re_poisk(string))\n",
    "\n",
    "strings = [\n",
    "    'attraction', # atraction\n",
    "    \"buzzzz\",     # buz\n",
    "    'abv',\n",
    "    'mewmewNnyaaa',\n",
    "    'aaaaaqqqqqqqbbbbb'\n",
    "]\n",
    "\n",
    "    \n",
    "for string in strings:\n",
    "    print(re_poisk(string))\n",
    "\n",
    "\n",
    "    \n",
    "'''\n",
    "\n",
    "Вам дана последовательность строк.\n",
    "В каждой строке замените все вхождения нескольких одинаковых \n",
    "букв на одну букву.\n",
    "Буквой считается символ из группы \\w.\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "attraction\n",
    "buzzzz\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "atraction\n",
    "buz\n",
    "\n",
    "\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "htis si a etxt\n",
      "htis' !si. ?1nce,\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'\\nВам дана последовательность строк.\\nВ каждой строке поменяйте местами две первых буквы в каждом слове, состоящем хотя бы из двух букв.\\nБуквой считается символ из группы \\\\w.\\n\\nSample Input:\\n\\nthis is a text\\n\"this\\' !is. ?n1ce,\\n\\nSample Output:\\n\\nhtis si a etxt\\n\"htis\\' !si. ?1nce,\\n'"
      ]
     },
     "execution_count": 92,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import re\n",
    "import sys\n",
    "\n",
    "pattern = r\"(\\b\\w)(\\w)\"\n",
    "\n",
    "def re_poisk(string):\n",
    "    match_obj = re.findall(pattern, string)\n",
    "    \n",
    "    \n",
    "    \n",
    "    for i in match_obj:\n",
    "        pattern_2 =  r\"\\b\"+''.join(i)\n",
    "        #print(pattern_2)\n",
    "        \n",
    "        string = re.sub(\n",
    "            pattern_2, \n",
    "            ''.join(reversed(i)), \n",
    "            string.strip()\n",
    "        )\n",
    "    return string\n",
    " \n",
    "\n",
    "for line in sys.stdin:\n",
    "    string = line.strip()\n",
    "    print(re_poisk(string))\n",
    "\n",
    "strings = [\n",
    "    'this is a text',\n",
    "    \"this' !is. ?n1ce,\",\n",
    "]\n",
    "\n",
    "    \n",
    "for string in strings:\n",
    "    print(re_poisk(string))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "'''\n",
    "Вам дана последовательность строк.\n",
    "В каждой строке поменяйте местами две первых буквы в каждом слове, состоящем хотя бы из двух букв.\n",
    "Буквой считается символ из группы \\w.\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "this is a text\n",
    "\"this' !is. ?n1ce,\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "htis si a etxt\n",
    "\"htis' !si. ?1nce,\n",
    "'''\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "There’ll be no more \"argh\"\n",
      "argh AaAaAaA\n"
     ]
    }
   ],
   "source": [
    "a = '''\n",
    "\n",
    "Вам дана последовательность строк.\n",
    "В каждой строке замените первое вхождение слова, \n",
    "состоящего только из латинских букв \"a\" (регистр не важен),\n",
    "на слово \"argh\".\n",
    "\n",
    "Примечание:\n",
    "Обратите внимание на параметр count у функции sub.\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "There’ll be no more \"Aaaaaaaaaaaaaaa\"\n",
    "AaAaAaA AaAaAaA\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "There’ll be no more \"argh\"\n",
    "argh AaAaAaA\n",
    "\n",
    "\n",
    "'''\n",
    "################### SOLVED\n",
    "import sys\n",
    "import re\n",
    "\n",
    "def re_cut(string):\n",
    "    pattern = r\"\\b[Aa]+\\b\"\n",
    "    return re.sub(pattern, \"argh\", string.strip(), 1)\n",
    "\n",
    "\n",
    "\n",
    "for string in sys.stdin:\n",
    "    print( re_cut(string) )\n",
    "    \n",
    "    \n",
    "\n",
    "strings = [\n",
    "        'There’ll be no more \"Aaaaaaaaaaaaaaa\"',\n",
    "        'AaAaAaA AaAaAaA',\n",
    "    ]\n",
    "\n",
    "for string in strings:\n",
    "    fixed_typos = re_cut(string)\n",
    "    print(fixed_typos)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "################### SOLVED\n",
    "import sys\n",
    "import re\n",
    "\n",
    "\n",
    "pattern = r\"human\"\n",
    "\n",
    "for string in sys.stdin:\n",
    "    print( re.sub(pattern, \"computer\", string.strip()))\n",
    "        \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "I need to understand the computer mind computerity\n"
     ]
    }
   ],
   "source": [
    "import re\n",
    "pattern = r\"human\"\n",
    "string = \"I need to understand the human mind humanity\"\n",
    "\n",
    "\n",
    "fixed_typos = re.sub(pattern, \"computer\", string)\n",
    "print(fixed_typos)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 197,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n",
      "1 2 3\n",
      "8 9 4\n",
      "7 6 5\n"
     ]
    }
   ],
   "source": [
    "\n",
    "def zm(n):\n",
    "    dx, dy = 1, 0\n",
    "    x, y = 0, 0\n",
    "    arr = [[None] * n for _ in range(n)]\n",
    "    for i in range(1, n**2+1):\n",
    "        arr[x][y] = i\n",
    "        nx, ny = x+dx, y+dy\n",
    "        if 0 <= nx < n and 0 <= ny < n and not arr[nx][ny]:\n",
    "            x, y = nx, ny\n",
    "        else:\n",
    "            dx, dy = -dy, dx\n",
    "            x, y = x+dx, y+dy\n",
    "    for x in list(zip(*arr)):\n",
    "        print(*x)\n",
    " \n",
    "zm(int(input()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 207,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n",
      "[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n",
      "1 2 3 4\n",
      "12 13 14 5\n",
      "11 16 15 6\n",
      "10 9 8 7\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "\n",
    "Дополнительная\n",
    "Выведите таблицу размером n×n n \\times n n×n, заполненную числами \n",
    "от 1 1 1 до n2 n^2 n2 по спирали, выходящей из левого верхнего угла \n",
    "и закрученной по часовой стрелке, как показано в примере (здесь n=5 n=5 n=5):\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "5\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "1 2 3 4 5\n",
    "16 17 18 19 6\n",
    "15 24 25 20 7\n",
    "14 23 22 21 8\n",
    "13 12 11 10 9\n",
    "\n",
    "\n",
    "'''\n",
    "def zm(n):\n",
    "    helps = 0\n",
    "    dy, dx = 0, 1\n",
    "    y, x = 0, 0\n",
    "    arr = [[None] * n for _ in range(n)]\n",
    "    if helps: print(arr)\n",
    "    for i in range(1, n**2+1):\n",
    "        arr[y][x] = i\n",
    "        \n",
    "        ny, nx = y+dy, x+dx\n",
    "        \n",
    "        \n",
    "        \n",
    "        if 0 <= ny < n and 0 <= nx < n and not arr[ny][nx]:\n",
    "            if helps: print('\\tif=========1', 0 <= ny < n,  0 <= nx < n, not arr[ny][nx])\n",
    "            y, x = ny, nx\n",
    "        else:\n",
    "            if helps: print('\\tif---------2', 0 <= ny < n,  0 <= nx < n)\n",
    "            dy, dx = dx, -dy\n",
    "            y, x = y+dy, x+dx\n",
    "            \n",
    "        if helps: print('y:', y, 'x:', x, '\\tny:', ny, 'nx:', nx, '\\tdy:', dy, 'dx:', dx)\n",
    "        \n",
    "    if helps: print(arr)\n",
    "    [print(*i) for i in [j for j in arr]]\n",
    "\n",
    "\n",
    " \n",
    "zm(int(input()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 209,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n",
      "1  2  3  4  \n",
      "15  16  17  5  \n",
      "15  14  13  6  \n",
      "11  12  13  7  \n"
     ]
    }
   ],
   "source": [
    "#a = int(input())\n",
    "a = 4 # код автоматизирован для 3!!!\n",
    "#a = 4 # числа не те кроме первой строки и последнего столбца,верные направления!!\n",
    "#a = 5\n",
    "lst = [[0 for j in range(a)] for i in range(a)] \n",
    " \n",
    "print(lst)\n",
    " \n",
    "n = 1 # замена i для вычислений\n",
    "s = 0 # можно ли ее заменить i?? нет, считает строки\n",
    " \n",
    "p = a * (a - s) - 1 # счетчик\n",
    "for i in lst:\n",
    "  for j, t in enumerate(i): # счетчик\n",
    " \n",
    "    if s == 0:\n",
    "      t = n\n",
    " \n",
    "    else:\n",
    "      if j == a-1:\n",
    "        t = a + s # счетчик\n",
    "        #print('Thet')\n",
    " \n",
    "      else:\n",
    "        t = p # ВОТ СЮДА надо вставить супер-формулу или заполнять таблицу вместо моментального вывода\n",
    "        #print('This')\n",
    "      if s%2 == 1:\n",
    "        p += 1\n",
    "      else:\n",
    "        p -= 1\n",
    "    #print (p, t)\n",
    "    print(t, ' ', end = '')\n",
    "    n +=1\n",
    " \n",
    " \n",
    "  s += 1\n",
    "  if s%2 == 0:\n",
    "    p -= 4\n",
    "  #p = a * 2 + 1\n",
    "  print()\n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {
    "scrolled": true,
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>\n",
       "\n",
       "</style>\n",
       "\n",
       "# https://github.com/jupyter/notebook/issues/2897\n",
       "# https://www.google.ru/search?ie=UTF-8&q=jupiter%20notebook%20extensions%20output%20right\n",
       "print(1)\n"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%%html\n",
    "<style>\n",
    "#notebook-container {\n",
    "    width: 90%;\n",
    "    background-color: #EEE\n",
    "}\n",
    "\n",
    ".code_cell {\n",
    "   flex-direction: row !important;\n",
    "}\n",
    "\n",
    ".code_cell .output_wrapper {\n",
    "    width: 50%;\n",
    "    background-color: #FFF\n",
    "}\n",
    "\n",
    ".code_cell .input {\n",
    "    width: 50%;\n",
    "    background-color: #FFF\n",
    "}\n",
    "</style>\n",
    "\n",
    "# https://github.com/jupyter/notebook/issues/2897\n",
    "# https://www.google.ru/search?ie=UTF-8&q=jupiter%20notebook%20extensions%20output%20right\n",
    "print(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>#notebook-container {width: 90%; background-color: #EEE}.code_cell {flex-direction: row !important;}.code_cell .output_wrapper {width: 50%; background-color: #FFF;}.code_cell .input {width: 50%; background-color: #FFF;}</style>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "execution_count": 123,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from IPython.core.display import HTML\n",
    "HTML(\"<style>#notebook-container {width: 90%; background-color: #EEE}\"\n",
    "    +\".code_cell {flex-direction: row !important;}\"\n",
    "    +\".code_cell .output_wrapper {width: 50%; background-color: #FFF;}\"\n",
    "    +\".code_cell .input {width: 50%; background-color: #FFF;}</style>\")\n",
    "#print(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 280,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "None\n",
      "<re.Match object; span=(0, 8), match='testtest'>\n",
      "\t ('testtest', 'test')\n",
      "<re.Match object; span=(0, 6), match='blabla'>\n",
      "\t ('blabla', 'bla')\n",
      "<re.Match object; span=(0, 6), match='123123'>\n",
      "\t ('123123', '123')\n",
      "None\n",
      "None\n",
      "None\n",
      "<re.Match object; span=(0, 2), match='22'>\n",
      "\t ('22', '2')\n",
      "testtest chow-chow\n",
      "blabla is a tandem repetition\n",
      "123123 is good too\n",
      "22\n",
      "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n",
      "[]\n",
      "[('testtest', 'test')]\n",
      "[('blabla', 'bla')]\n",
      "[('123123', '123')]\n",
      "[]\n",
      "[]\n",
      "[]\n",
      "[('22', '2')]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'\\n\\n\\nВам дана последовательность строк.\\nВыведите строки, содержащие слово, состоящее из двух одинаковых частей (тандемный повтор).\\n\\nSample Input:\\n\\nblabla is a tandem repetition\\n123123 is good too\\ngo go\\naaa\\n\\nSample Output:\\n\\nblabla is a tandem repetition\\n123123 is good too\\n\\n\\n'"
      ]
     },
     "execution_count": 280,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import re\n",
    "\n",
    "pattern = r\"((\\b\\w+\\B)\\2\\b)\"\n",
    "strings = [\n",
    "    \"test-test chow-chow\",\n",
    "    \"testtest chow-chow\",\n",
    "    \"blabla is a tandem repetition\", # +\n",
    "    \"123123 is good too\",# +\n",
    "    \"go go\",\n",
    "    \"aaa\",\n",
    "    \"xxxxx\",\n",
    "    \"22\"\n",
    "]\n",
    "\n",
    "for string in strings:\n",
    "    match_obj = re.match(pattern, string)\n",
    "    print(match_obj)\n",
    "    if hasattr(match_obj, 'groups'):\n",
    "        print('\\t', match_obj.groups())\n",
    "\n",
    "[print(string) for string in strings if len(re.findall(pattern, string)) > 0]\n",
    "\n",
    "print('%'*50)\n",
    "[print(re.findall(pattern, string)) for string in strings]\n",
    "\n",
    "\n",
    "################### SOLVED\n",
    "import sys\n",
    "import re\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "pattern = r\"((\\b\\w+\\B)\\2\\b)\"\n",
    "\n",
    "for line in sys.stdin:\n",
    "    string = line\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string.strip())\n",
    "        \n",
    "'''\n",
    "\n",
    "\n",
    "Вам дана последовательность строк.\n",
    "Выведите строки, содержащие слово, состоящее из двух одинаковых частей (тандемный повтор).\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "blabla is a tandem repetition\n",
    "123123 is good too\n",
    "go go\n",
    "aaa\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "blabla is a tandem repetition\n",
    "123123 is good too\n",
    "\n",
    "\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 229,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "* 122221 \t\t <re.Match object; span=(0, 0), match=''>\n",
      "* 122222 \t\t <re.Match object; span=(0, 0), match=''>\n",
      "* blabla is a tandem repetition \t\t <re.Match object; span=(0, 0), match=''>\n",
      "----------------------------------------\n"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "\n",
    "import re\n",
    "\n",
    "task = [\n",
    "    '122221',\n",
    "    '122222',\n",
    "    'blabla is a tandem repetition',\n",
    "]\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    print('*', string, '\\t'*2, match_object)\n",
    "    \n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "\n",
    "#pattern = r\"(?=(.))\\1{2,}\" повторы символов\n",
    "pattern = r\"\\b\"\n",
    "\n",
    "for string in task:\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        pass\n",
    "        #print(string)\n",
    "else:\n",
    "    print('-'*40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 216,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\\w denotes word character\n",
      "----------------------------------------\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "\n",
    "Вам дана последовательность строк.\n",
    "Выведите строки, содержащие обратный слеш \"\\﻿\".\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "\\w denotes word character\n",
    "No slashes here\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "\\w denotes word character\n",
    "\n",
    "\n",
    "'''\n",
    "import re\n",
    "\n",
    "task = [\n",
    "    '\\w denotes word character',               # +\n",
    "    'No slashes here',                 # -\n",
    "]\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    #print('*', string, '\\t'*2, match_object)\n",
    "    \n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "\n",
    "pattern = r\"\\\\\"\n",
    "\n",
    "for string in task:\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string)\n",
    "else:\n",
    "    print('-'*40)\n",
    "    \n",
    "################### SOLVED\n",
    "import sys\n",
    "import re\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "pattern = r\"\\\\\"\n",
    "\n",
    "for line in sys.stdin:\n",
    "    string = line\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string.strip())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 160,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "zabcz\n",
      "zzxzz\n",
      "----------------------------------------\n"
     ]
    }
   ],
   "source": [
    "a = '''\n",
    "\n",
    "Вам дана последовательность строк.\n",
    "Выведите строки, содержащие две буквы \"z﻿\", между которыми ровно три символа.\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "zabcz\n",
    "zzz\n",
    "zzxzz\n",
    "zz\n",
    "zxz\n",
    "zzxzxxz\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "zabcz\n",
    "zzxzz\n",
    "\n",
    "\n",
    "'''\n",
    "\n",
    "\n",
    "import re\n",
    "\n",
    "task = [\n",
    "    'zabcz',               # +\n",
    "    'zzz',                 # -\n",
    "    'zzxzz',               # +\n",
    "    'zz',                  # -\n",
    "    'zxz',               # -\n",
    "    'zzxzxxz',             # -\n",
    "]\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    #print('*', string, '\\t'*2, match_object)\n",
    "    \n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "\n",
    "pattern = r\"z.{3}z\"\n",
    "\n",
    "for string in task:\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string)\n",
    "else:\n",
    "    print('-'*40)\n",
    "    \n",
    "################### SOLVED\n",
    "import sys\n",
    "import re\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "pattern = r\"z.{3}z\"\n",
    "\n",
    "for line in sys.stdin:\n",
    "    string = line\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string.strip())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "cat\n",
      "catapult and cat\n",
      "\"cat\"\n",
      "!cat?\n",
      "----------------------------------------\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "\n",
    "Вам дана последовательность строк.\n",
    "Выведите строки, содержащие \"cat\" в качестве слова.\n",
    "\n",
    "Примечание:\n",
    "Для работы со словами используйте группы символов \\b и \\B.\n",
    "Описание этих групп вы можете найти в документации.\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "cat\n",
    "catapult and cat\n",
    "catcat\n",
    "concat\n",
    "Cat\n",
    "\"cat\"\n",
    "!cat?\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "cat\n",
    "catapult and cat\n",
    "\"cat\"\n",
    "!cat?\n",
    "\n",
    "\n",
    "'''\n",
    "\n",
    "import re\n",
    "\n",
    "task = [\n",
    "    'cat',               # +\n",
    "    'catapult and cat',  # +\n",
    "    'catcat',\n",
    "    'concat',\n",
    "    'Cat',\n",
    "    '\"cat\"',             # +\n",
    "    '!cat?',             # +\n",
    "]\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    #print('*', string, '\\t'*2, match_object)\n",
    "    \n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "\n",
    "pattern = r\"(\\b)cat(\\b)\"\n",
    "\n",
    "for string in task:\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string)\n",
    "else:\n",
    "    print('-'*40)\n",
    "    \n",
    "\n",
    "################### SOLVED\n",
    "import sys\n",
    "import re\n",
    "\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    match_object = re.search(pattern, string)\n",
    "    if hasattr(match_object, 'span'): return 1\n",
    "    return 0\n",
    "\n",
    "pattern = r\"(\\b)cat(\\b)\"\n",
    "\n",
    "for line in sys.stdin:\n",
    "    string = line\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string.strip())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "metadata": {
    "scrolled": true,
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 3\n",
      "(0, 0)\n",
      "cat\n",
      "0 3\n",
      "(0, 0)\n",
      "catapult and cat\n",
      "0 3\n",
      "(0, 0)\n",
      "catcat\n",
      "3 6\n",
      "(0, 0)\n",
      "None\n",
      "1 4\n",
      "(1, 1)\n",
      "\"cat\"\n",
      "1 4\n",
      "(1, 1)\n",
      "!cat?\n",
      "----------------------------------------\n"
     ]
    }
   ],
   "source": [
    "import re\n",
    "\n",
    "task = [\n",
    "    'cat',               # +\n",
    "    'catapult and cat',  # +\n",
    "    'catcat',\n",
    "    'concat',\n",
    "    'Cat',\n",
    "    '\"cat\"',             # +\n",
    "    '!cat?',             # +\n",
    "]\n",
    "\n",
    "\n",
    "pattern = r\"\\b\"\n",
    "\n",
    "def re_poisk_pattern_in_begining(pattern, string):\n",
    "    helps = 1\n",
    "    #print('\\t', string)\n",
    "    match_object = re.search(pattern, string)\n",
    "    \n",
    "    if hasattr(match_object, 'span'):\n",
    "        span = match_object.span()\n",
    "        if helps: print(*span)\n",
    "        \n",
    "        match_object = re.search(r\"\\b\", string)\n",
    "        span2 = match_object.span()\n",
    "        print(span2)\n",
    "        if span[0] == span2[0]:\n",
    "            return 1\n",
    "        \n",
    "    else:\n",
    "        if helps: print(match_object)\n",
    "\n",
    "'''\n",
    "for string in task:\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string)\n",
    "    else:\n",
    "        print('-', string)\n",
    "else:\n",
    "    print('-'*40)\n",
    "'''\n",
    "\n",
    "pattern = r\"cat\"\n",
    "\n",
    "for string in task:\n",
    "    if re_poisk_pattern_in_begining(pattern, string):\n",
    "        print(string)\n",
    "    #else:\n",
    "        #print('-', string)\n",
    "else:\n",
    "    print('-'*40)\n",
    "################### SOLVED\n",
    "\n",
    "import sys\n",
    "import re\n",
    "\n",
    "pattern = r\"cat\"\n",
    "\n",
    "for line in sys.stdin:\n",
    "    line = line.rstrip()\n",
    "    string = line\n",
    "    match_object = re.findall(pattern, string)\n",
    "    if len(match_object) >= 2:\n",
    "        print(string)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "catcat\n",
      "cat and cat\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "\n",
    "Вам дана последовательность строк.\n",
    "Выведите строки, содержащие \"cat\" в качестве подстроки хотя бы два раза.\n",
    "\n",
    "Примечание:\n",
    "Считать все строки по одной из стандартного потока ввода вы можете, например, так\n",
    "\n",
    "import sys\n",
    "\n",
    "for line in sys.stdin:\n",
    "    line = line.rstrip()\n",
    "    # process line\n",
    "\n",
    "\n",
    "Sample Input:\n",
    "\n",
    "catcat\n",
    "cat and cat\n",
    "catac\n",
    "cat\n",
    "ccaatt\n",
    "\n",
    "Sample Output:\n",
    "\n",
    "catcat\n",
    "cat and cat\n",
    "\n",
    "'''\n",
    "\n",
    "import re\n",
    "\n",
    "task = [\n",
    "    'catcat',\n",
    "    'cat and cat',\n",
    "    'catac',\n",
    "    'cat',\n",
    "    'ccaatt'\n",
    "]\n",
    "\n",
    "pattern = r\"cat\"\n",
    "\n",
    "\n",
    "\n",
    "for string in task:\n",
    "    match_object = re.findall(pattern, string)\n",
    "    if len(match_object) >= 2:\n",
    "        print(string)\n",
    "\n",
    "################### SOLVED\n",
    "\n",
    "import sys\n",
    "import re\n",
    "\n",
    "pattern = r\"cat\"\n",
    "\n",
    "for line in sys.stdin:\n",
    "    line = line.rstrip()\n",
    "    string = line\n",
    "    match_object = re.findall(pattern, string)\n",
    "    if len(match_object) >= 2:\n",
    "        print(string)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 230,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<re.Match object; span=(0, 3), match='acc'>\n",
      "['abc', 'a.c', 'aac', 'a-c', 'aBc', 'azc']\n",
      "abc, abc, abc, abc, abc, abc\n",
      "<re.Match object; span=(0, 3), match='aba'>\n",
      "['aba', 'aba']\n",
      "[('test-test', 'test'), ('chow-chow', 'chow')]\n",
      "MIN_REPEAT 0 MAXREPEAT\n",
      "  SUBPATTERN 1 0 0\n",
      "    LITERAL 116\n",
      "    LITERAL 101\n",
      "LITERAL 120\n",
      "LITERAL 116\n",
      "\n",
      " 0. INFO 4 0b0 2 MAXREPEAT (to 5)\n",
      " 5: REPEAT 11 0 MAXREPEAT (to 17)\n",
      " 9.   MARK 0\n",
      "11.   LITERAL_UNI_IGNORE 0x74 ('t')\n",
      "13.   LITERAL_UNI_IGNORE 0x65 ('e')\n",
      "15.   MARK 1\n",
      "17: MIN_UNTIL\n",
      "18. LITERAL_UNI_IGNORE 0x78 ('x')\n",
      "20. LITERAL_UNI_IGNORE 0x74 ('t')\n",
      "22. SUCCESS\n",
      "<re.Match object; span=(0, 4), match='TEXT'>\n"
     ]
    }
   ],
   "source": [
    "import re\n",
    "\n",
    "# print(re.match)\n",
    "# print(re.search)\n",
    "# print(re.findall)\n",
    "# print(re.sub)\n",
    "\n",
    "# [] -- можно указать множество подходящих символов\n",
    "# . ^ $ * + ? { } [ ] \\ | ( ) -- метасимволы\n",
    "# \\d ~ [0-9] -- цифры\n",
    "# \\D ~ [^0-9]\n",
    "# \\s ~ [ \\t\\n\\r\\f\\v] -- пробельные символы\n",
    "# \\S ~ [^ \\t\\n\\r\\f\\v]\n",
    "# \\w ~ [a-zA-Z0-9_] -- буквы + цифры + _\n",
    "# \\W ~ [^a-zA-Z0-9_]\n",
    "\n",
    "pattern = r\"a.c\"\n",
    "string = \"acc\"\n",
    "match_object = re.match(pattern, string)\n",
    "print(match_object)\n",
    "\n",
    "string = \"abc, a.c, aac, a-c, aBc, azc\"\n",
    "all_inclusions = re.findall(pattern, string)\n",
    "print(all_inclusions)\n",
    "\n",
    "fixed_typos = re.sub(pattern, \"abc\", string)\n",
    "print(fixed_typos)\n",
    "\n",
    "# pattern = r\"ab{2,4}a\"\n",
    "# string = \"aa, aba, abba, abbba, abbbba\"\n",
    "# all_inclusions = re.findall(pattern, string)\n",
    "# print(all_inclusions)\n",
    "\n",
    "pattern = r\"a[ab]+?a\"\n",
    "string = \"abaaba\"\n",
    "print(re.match(pattern, string))\n",
    "print(re.findall(pattern, string))\n",
    "\n",
    "\n",
    "import re\n",
    "\n",
    "pattern = r\"((\\w+)-\\2)\"\n",
    "string = \"test-test chow-chow\"\n",
    "duplicates = re.findall(pattern, string)\n",
    "print(duplicates)\n",
    "\n",
    "import re\n",
    "\n",
    "x = re.match(r\"(te)*?xt\", \"TEXT\", re.IGNORECASE | re.DEBUG)\n",
    "print(x)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "########################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################\n"
     ]
    }
   ],
   "source": [
    "print('#'*1000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2 2\n",
      "3 5\n",
      "-1 7\n",
      "0 1\n",
      "end\n",
      "7 10 \n",
      "11 15 \n",
      "17 4 \n",
      "3 9 \n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[([None, None], None),\n",
       " ([None, None], None),\n",
       " ([None, None], None),\n",
       " ([None, None], None)]"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "line, matrix, lI = input(), [], 0\n",
    " \n",
    "while line != 'end':\n",
    "    matrix +=[[int(i) for i in line.split()]]\n",
    "    line = input()\n",
    "    lI += 1\n",
    " \n",
    "lJ = len(matrix[0])\n",
    " \n",
    "[([print(matrix[i - 1][j] + matrix[i][j - 1] + matrix[i][(j + 1) % lJ] + matrix[(i + 1) % lI][j], end=' ') for j in range(lJ)], print()) for i in range(lI)]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "468\n",
      "468\n"
     ]
    }
   ],
   "source": [
    "print(sum(map(int,['123', '345'])))\n",
    "print(sum((int(i) for i in ['123', '345'])))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n",
      "4\n",
      "6\n",
      "8\n",
      "0\n",
      "------------------------------\n",
      "[2, 4, 6, 8, 0]\n",
      "------------------------------\n",
      "[2, 4, 6, 8, 0]\n",
      "------------------------------\n"
     ]
    }
   ],
   "source": [
    " def even(x):\n",
    "    return x % 2 == 0\n",
    "\n",
    "for i in filter(even, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]):\n",
    "    print(i)\n",
    "else:\n",
    "    print('-'*30)\n",
    "    \n",
    "# можно проще но забъет оперативку\n",
    "print(list(filter(even, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0])))\n",
    "print('-'*30)\n",
    "\n",
    "# even через lambda\n",
    "even = lambda x: x % 2 == 0\n",
    "print(list(filter(even, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0])))\n",
    "print('-'*30)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[17, 23, 21]\n",
      "[('Putin', 'Vlad', 'Vladov'), ('Lenin', 'Vladimir', \"Il'ich\"), ('Byanka', 'Vanila', 'Vekalinka')]\n",
      "-------------------------\n",
      "[('Putin', 'Vlad', 'Vladov'), ('Lenin', 'Vladimir', \"Il'ich\"), ('Byanka', 'Vanila', 'Vekalinka')]\n",
      "-------------------------\n",
      "[('Lenin', 'Vladimir', \"Il'ich\"), ('Byanka', 'Vanila', 'Vekalinka'), ('Putin', 'Vlad', 'Vladov')]\n",
      "-------------------------\n",
      "[('Lenin', 'Vladimir', \"Il'ich\"), ('Byanka', 'Vanila', 'Vekalinka'), ('Putin', 'Vlad', 'Vladov')]\n",
      "-------------------------\n",
      "['cba', 'abb', 'abc']\n",
      "-------------------------\n",
      "['cba', 'abb', 'abc']\n",
      "-------------------------\n"
     ]
    }
   ],
   "source": [
    "# сортируем кортеж по длине стокки из всех эемнтов\n",
    "x = [\n",
    "    ('Putin', 'Vlad', 'Vladov'),\n",
    "    ('Byanka', 'Vanila', 'Vekalinka'),\n",
    "    ('Lenin', 'Vladimir', 'Il\\'ich')\n",
    "]\n",
    "def length(name):\n",
    "    return len(' '.join(name))\n",
    "name_lengths =  [length(name) for name in x]\n",
    "print(name_lengths)\n",
    "x.sort(key=length)\n",
    "print(x)\n",
    "\n",
    "print('-'*25)\n",
    "\n",
    "# simply\n",
    "x.sort(key=lambda name: len(' '.join(name)))\n",
    "print(x)\n",
    "\n",
    "print('-'*25)\n",
    "import operator as op\n",
    "x.sort(key=op.itemgetter(-1))\n",
    "print(x)\n",
    "print('-'*25)\n",
    "\n",
    "# another\n",
    "import operator as op\n",
    "from functools import partial\n",
    "sort_by_last = partial(list.sort, key=op.itemgetter(-1))\n",
    "sort_by_last(x)\n",
    "print(x)\n",
    "print('-'*25)\n",
    "\n",
    "# for what? universal?? I don't know\n",
    "y = ['abc', 'cba', 'abb']\n",
    "sort_by_last(y)\n",
    "print(y)\n",
    "print('-'*25)\n",
    "\n",
    "y = ['abc', 'cba', 'abb']\n",
    "y.sort(key=op.itemgetter(-1))\n",
    "print(y)\n",
    "print('-'*25)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "9\n",
      "20\n",
      "False\n",
      "2\n",
      "3\n",
      "<built-in method sort of list object at 0x7f0d41ec8b08>\n"
     ]
    }
   ],
   "source": [
    "import operator as op\n",
    "print(op.add(4,5))\n",
    "print(op.mul(4,5))\n",
    "print(op.contains([1, 2, 3], 4))\n",
    "\n",
    "x = [1, 2, 3]\n",
    "f = op.itemgetter(1) # f(x) == x[1]\n",
    "print(f(x))\n",
    "\n",
    "x = {'123':3}\n",
    "f = op.itemgetter('123') # f(x) == x['123']\n",
    "print(f(x))\n",
    "\n",
    "f = op.attrgetter('sort') # f(x) == x.sort\n",
    "print(f([]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "13\n",
      "13\n"
     ]
    }
   ],
   "source": [
    "from functools import partial\n",
    "\n",
    "print(int('1101', base=2))\n",
    "# another\n",
    "int_2 = partial(int, base=2)\n",
    "print(int_2('1101'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "False\n",
      "True\n",
      "True\n",
      "[2, 4, 6, 8, 0]\n",
      "------------------------------\n"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "\n",
    "\n",
    "'''\n",
    "\n",
    "Лямбда функции предоставляют нам удобный способ \n",
    "создать функцию «прямо на месте».\n",
    "Но иногда, когда нужно создавать много однотипных \n",
    "лямбда функций, еще удобнее будет создать функцию, \n",
    "которая будет их генерировать.\n",
    "\n",
    "Реализуйте функцию mod_checker(x, mod=0), которая \n",
    "будет генерировать лямбда функцию от одного аргумента \n",
    "y, которая будет возвращать True, если остаток от деления \n",
    "y на x равен mod, и False иначе.\n",
    "\n",
    "﻿Пример использования:\n",
    "\n",
    "mod_3 = mod_checker(3)\n",
    "\n",
    "print(mod_3(3)) # True\n",
    "print(mod_3(4)) # False\n",
    "\n",
    "mod_3_1 = mod_checker(3, 1)\n",
    "print(mod_3_1(4)) # True\n",
    "\n",
    "'''\n",
    "\n",
    "\n",
    "\n",
    "def mod_checker(x, mod=0):\n",
    "    return lambda y: y % x == mod\n",
    "\n",
    "mod_3 = mod_checker(3)\n",
    "print(mod_3(3)) # True\n",
    "print(mod_3(4)) # False\n",
    "\n",
    "mod_3_1 = mod_checker(3, 1)\n",
    "print(mod_3_1(4)) # True\n",
    "\n",
    "\n",
    "print(mod_3(3)) # True\n",
    "\n",
    "even = lambda x: x % 2 == 0\n",
    "print(list(filter(even, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0])))\n",
    "print('-'*30)\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "    RanfomIterator(k) - new iterator for k random numbers in (0, 1)\n",
      "\n",
      "    Uses random.random\n",
      "    \n"
     ]
    }
   ],
   "source": [
    "from random import random\n",
    "\n",
    "class RanfomIterator:\n",
    "    \"\"\"\n",
    "    RanfomIterator(k) - new iterator for k random numbers in (0, 1)\n",
    "\n",
    "    Uses random.random\n",
    "    \"\"\"\n",
    "    pass\n",
    "print(RanfomIterator.__doc__)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# print(\"abc\" in \"abcba\")\n",
    "# print(\"abce\" in \"abcba\")\n",
    "\n",
    "# print(\"cabcd\".find(\"abc\", 1))  # индекс первого вхождения или -1\n",
    "# print(\"cabcd\"[1:].find(\"abc\"))\n",
    "# print(str.find.__doc__)\n",
    "\n",
    "# print(\"cabcd\".index(\"abc\"))  # индекс первого вхождения или ValueError\n",
    "# print(\"cabcd\".index(\"aec\"))\n",
    "\n",
    "# s = \"The whale in black fled across the desert, and the gunslinger followed\"\n",
    "# print(s.startswith((\"The woman\", \"The dog\", \"The man in black\")))\n",
    "# print(s.startswith.__doc__)\n",
    "\n",
    "# s = \"image.png\"\n",
    "# print(s.endswith(\".png\"))\n",
    "\n",
    "# s = \"abacaba\"\n",
    "# print(s.count(\"aba\"))\n",
    "# print(s.count.__doc__)\n",
    "# print(s.find(\"aba\"))\n",
    "# print(s.rfind(\"aba\"))\n",
    "\n",
    "# s = \"The man in black fled across the desert, and the gunslinger followed\"\n",
    "# print(s.lower())\n",
    "# print(s.upper())\n",
    "# print(s.count(\"the\"))\n",
    "# print(s.lower().count(\"the\"))\n",
    "\n",
    "# s = \"1,2,3,4\"\n",
    "# print(s)\n",
    "# print(s.replace(\",\", \", \", 2))\n",
    "# print(s.replace.__doc__)\n",
    "\n",
    "# s = \"1\\t\\t 2  3       4       \"\n",
    "# print(s.split())\n",
    "# print(s.split.__doc__)\n",
    "\n",
    "# s = \"_*__1, 2, 3, 4__*_\"\n",
    "# print(repr(s.rstrip(\"*_\")))\n",
    "# print(repr(s.lstrip(\"*_\")))\n",
    "# print(repr(s.strip(\"*_\")))\n",
    "\n",
    "# numbers = map(str, [1, 2, 3, 4, 5])\n",
    "# print(repr(\" \".join(numbers)))\n",
    "\n",
    "\n",
    "# capital = 'London is the capital of Great Britain'\n",
    "# template = '{} is the capital of {}'\n",
    "# print(template.format(\"London\", \"Great Britain\"))\n",
    "# print(template.format(\"Vaduz\", \"Liechtenstein\"))\n",
    "# print(template.format.__doc__)\n",
    "\n",
    "\n",
    "# template = '{capital} is the capital of {country}'\n",
    "# print(template.format(capital=\"London\", country=\"Great Britain\"))\n",
    "# print(template.format(country=\"Liechtenstein\", capital=\"Vaduz\"))\n",
    "\n",
    "#\n",
    "# import requests\n",
    "# template = \"Response from {0.url} with code {0.status_code}\"\n",
    "#\n",
    "# res = requests.get(\"https://docs.python.org/3.5/\")\n",
    "# print(template.format(res))\n",
    "#\n",
    "# res = requests.get(\"https://docs.python.org/3.5/random\")\n",
    "# print(template.format(res))\n",
    "\n",
    "# from random import random\n",
    "# x = random()\n",
    "# print(x)\n",
    "# print(\"{:.3}\".format(x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "abababa aba 3\n",
      "----------\n",
      "abababa abc 0\n",
      "----------\n",
      "5 5\n",
      "S.count(sub[, start[, end]]) -> int\n",
      "\n",
      "Return the number of non-overlapping occurrences of substring sub in\n",
      "string S[start:end].  Optional arguments start and end are\n",
      "interpreted as in slice notation.\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "print('-'*10)\n",
    "\n",
    "s = \"aaaaa\"\n",
    "print(s.count(\"a\"),5)\n",
    "print(s.find(\"a\"),5)\n",
    "\n",
    "print('-'*10)\n",
    "\n",
    "s = \"abababa\"\n",
    "sub = 'aba'\n",
    "print(s.count(sub),3)\n",
    "print(s.rfind(sub),3)\n",
    "\n",
    "print('-'*10)\n",
    "\n",
    "\n",
    "\n",
    "def count_substr_in_str(string, sub):\n",
    "    j = 0\n",
    "    for i in range(len(string)):\n",
    "        \n",
    "        if sub in string[i:]:\n",
    "            print(string[i:])\n",
    "            j +=1\n",
    "        else:\n",
    "            break\n",
    "    return j\n",
    "\n",
    "\n",
    "s = \"abababa\"\n",
    "sub = 'aba'\n",
    "print(s, sub, count_substr_in_str(s,sub))\n",
    "print('-'*10)\n",
    "\n",
    "s = \"aaaaa\"\n",
    "sub = \"a\"\n",
    "print(s, sub, count_substr_in_str(s,sub))\n",
    "\n",
    "'''\n",
    "help = 0\n",
    "\n",
    "def count_substr_in_str_2(string, sub):\n",
    "    i,resalt = 0,0\n",
    "    \n",
    "    if help: print('find',string.find(sub))\n",
    "    \n",
    "    \n",
    "    while string[i:].find(sub) >= 0:#i < len(string):\n",
    "        \n",
    "        if help: print('i',i)\n",
    "        \n",
    "        if help: print('string[i:].find(sub)',string[i:].find(sub))\n",
    "        resalt += 1\n",
    "        if help: print('string[i:]',string[i:])\n",
    "        \n",
    "        i += 1 + string[i:].find(sub) \n",
    "        \n",
    "    return resalt\n",
    "#print('-'*10)\n",
    "\n",
    "\n",
    "if help: print('-'*10)\n",
    "s = \"abababa\"\n",
    "sub = 'aba'\n",
    "if help: print(s, sub, count_substr_in_str_2(s,sub))\n",
    "print(s,sub, count_substr_in_str_2(s,sub))\n",
    "if help: print(*range(10), sep='')\n",
    "\n",
    "print('-'*10)\n",
    "s = \"abababa\"\n",
    "sub = 'abc'\n",
    "print(s, sub, count_substr_in_str_2(s,sub))\n",
    "\n",
    "\n",
    "print('-'*10)\n",
    "\n",
    "s = \"aaaaa\"\n",
    "print(s.count(\"a\"),5)\n",
    "print(s.count.__doc__)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ababab\n",
      "aba\n",
      "2\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "Вашей программе на вход подаются две строки s и t,\n",
    "состоящие из строчных латинских букв.\n",
    "\n",
    "Выведите одно число – количество вхождений строки \n",
    "t в строку s.\n",
    "\n",
    "Пример:\n",
    "s = \"abababa\"\n",
    "t = \"aba\"\n",
    "\n",
    "Вхождения строки t в строку s:\n",
    "abababa\n",
    "abababa\n",
    "abababa\n",
    "'''\n",
    "s = input()\n",
    "sub = input()\n",
    "\n",
    "def count_substr_in_str_2(string, sub):\n",
    "    i,resalt = 0,0\n",
    "\n",
    "    while string[i:].find(sub) >= 0:\n",
    "        resalt += 1\n",
    "        i += 1 + string[i:].find(sub) \n",
    "    return resalt\n",
    "print(count_substr_in_str_2(s,sub))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "list [[9, 5, 3, 88], [0, 7, -1, -88], [-5, 2, 9, 44]]\n",
      "n 3\n",
      "m 4\n",
      "A:  [9, 5, 3, 88, 0, 7, -1, -88, -5, 2, 9, 44]\n",
      "\n",
      "\n",
      "\n",
      "FIN:  [93, 12, 93, 12, -81, -1, -81, -1, 46, 4, 46, 4]\n",
      "88  21  101  -32  \n",
      "-77  6  -69  131  \n",
      "55  16  48  4  \n"
     ]
    }
   ],
   "source": [
    "lst = [[9, 5, 3, 88], [0, 7, -1, -88], [-5, 2, 9, 44]]\n",
    "#lst = [[1, 1], [2, 2]]\n",
    "#lst = [1]\n",
    "fin = []\n",
    "\n",
    "f_top_down = []\n",
    "'''\n",
    "lst = []\n",
    "a = ''\n",
    "b = []\n",
    "while True:\n",
    "  a = [str(i) for i in input().split()]\n",
    "  if a[0] == 'end':\n",
    "    break\n",
    "  else:\n",
    "    for i in a:\n",
    "      b.append(int(i))\n",
    " \n",
    "  lst.append(b)\n",
    "  b = []\n",
    " \n",
    "#print(lst)\n",
    "\n",
    "print(a)\n",
    "print(b)\n",
    "'''\n",
    "print('list',lst)\n",
    "\n",
    "\n",
    "\n",
    " \n",
    "n = len(lst)\n",
    "m = len(lst[0])\n",
    "print('n',n)\n",
    "print('m',m)\n",
    "\n",
    "#raise 1\n",
    " \n",
    " \n",
    "#a = [[0 for j in range(m)] for i in range(n)] \n",
    "#a = [0 for j in range(m * n)] \n",
    "a = []\n",
    "for i in lst:\n",
    "  for j in i:\n",
    "    a.append(j)\n",
    "print('A: ', a)\n",
    " \n",
    "\n",
    "# Fin Заполняется суммой соседних элементов строк\n",
    "for i in lst:\n",
    "  for j, y in enumerate(i): \n",
    "    if m == 1 and n == 1:\n",
    "      c = y * 2\n",
    "    elif j == m-1:\n",
    "      c = i[j-m+1] + i[j-1]\n",
    "    else:\n",
    "      c = i[j+1] + i[j-1]\n",
    "    \n",
    "    #print('j',j,'y',y, 'c', c, 'i[]:', *i)\n",
    "    fin.append(c)\n",
    "    f_top_down.append(c)\n",
    "  print()\n",
    "print('FIN: ', fin)\n",
    "\n",
    "    \n",
    "\n",
    " \n",
    "    \n",
    "    \n",
    "    \n",
    "#  J посчитан правильно, но только для матрицы 3*3\n",
    " \n",
    "k = 0\n",
    "l = 0\n",
    "for j, t in enumerate(fin): #j=2\n",
    "  #print(j)\n",
    "\n",
    "  if n == 1:\n",
    "    k = t + t\n",
    "    print(k)\n",
    "    #print(n)\n",
    "  else:\n",
    "    for f in a:\n",
    "      l += 1\n",
    "      #if j > n:\n",
    "      #  a1 = a[j - n]\n",
    "      #  a2 = a[j - n - n]\n",
    "      if j == n and j == 2:\n",
    "        a1 = a[j - n]\n",
    "        k = t + a1\n",
    "      elif m == 1:\n",
    "        if j > m:\n",
    "          a1 = a[j +1 - n]\n",
    "          a2 = a[j - m]\n",
    "          #print(j, n, m)\n",
    "        #else:\n",
    "        #  a1 = a[j + m]\n",
    "        #  a2 = a[j - m]\n",
    "      else:\n",
    "        #if j >= m:\n",
    "          #a1 = a[j +1 - n]\n",
    "          #a2 = a[j - m]\n",
    "        if j + m >= m * n:\n",
    "          a1 = a[j - m] \n",
    "          a2 = a[j + m - m * n] \n",
    "        else:\n",
    "          #print('j,m',j,m)\n",
    "          a1 = a[j - m] \n",
    "          a2 = a[j + m]\n",
    " \n",
    "    #if n == 2:\n",
    "      #k = t + a[j + n]\n",
    "    #else:\n",
    "      k = a1 + a2 \n",
    "       \n",
    "    #print(k, t, a1, a2)\n",
    " \n",
    "      f_top_down[j] = k\n",
    "      #print(f_top_down[j], ' ', end = '')\n",
    "    \n",
    "      k = t + a1 + a2\n",
    "      fin[j] = k\n",
    "      print(fin[j], ' ', end = '')\n",
    " \n",
    "      if l >= m:\n",
    "        print()\n",
    "        l = 0\n",
    " \n",
    " \n",
    " \n",
    " \n",
    "      break\n",
    "#print()\n",
    "  #break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'(123) 456-7890'"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "def create_phone_number(n):\n",
    "    return '(' + ''.join(map(str, n[0:3])) + ') ' + ''.join(map(str, n[3:6])) + '-' + ''.join(map(str, n[6:]))\n",
    "\n",
    "\n",
    "#.') '.str(''.join(n[3:5]))\n",
    "\n",
    "\n",
    "\n",
    "create_phone_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) \n",
    "# => returns \"(123) 456-7890\"\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ababac c c\n",
      "0\n"
     ]
    }
   ],
   "source": [
    "#s = \"1,2,3,4\"\n",
    "#print(s.replace.__doc__)\n",
    "\n",
    "\n",
    "\n",
    "#string, old_replaced, new_replaced = input(), input(), input()\n",
    "string = 'ababac'\n",
    "old_replaced = 'c'\n",
    "new_replaced = 'c'\n",
    "print(string, old_replaced, new_replaced)\n",
    "\n",
    "old_string = (string + '.')[:-1]\n",
    "\n",
    "\n",
    "#print(id(string))\n",
    "#print(id(original_string))\n",
    "#print(original_string)\n",
    "\n",
    "i = 0\n",
    "while True:\n",
    "    \n",
    "    string = string.replace(old_replaced, new_replaced)\n",
    "    \n",
    "    if string == old_string:\n",
    "        \n",
    "        break\n",
    "    else:\n",
    "        old_string = (string + '.')[:-1]\n",
    "        i += 1\n",
    "    \n",
    "    \n",
    "    if i == 1000:\n",
    "        break\n",
    "print(i)\n",
    "#print(string)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "\n",
    "Вашей программе на вход подаются три строки s, a, b, состоящие из строчных латинских букв.\n",
    "За одну операцию вы можете заменить все вхождения строки a в строку s на строку b.\n",
    "\n",
    "Например, s = \"abab\", a = \"ab\", b = \"ba\", тогда после выполнения одной операции строка s перейдет в строку \"baba\", после выполнения двух и операций – в строку \"bbaa\", и дальнейшие операции не будут изменять строку s.\n",
    "\n",
    "Необходимо узнать, после какого минимального количества операций в строке s не останется вхождений строки a. Если операций потребуется более 1000, выведите Impossible.\n",
    "\n",
    "Выведите одно число – минимальное число операций, после применения которых в строке s не останется вхождений строки a, или Impossible, если операций потребуется более 1000.\n",
    "\n",
    "Условие задачи было изменено 12.09.2018\n",
    "\n",
    "Sample Input 1:\n",
    "\n",
    "ababa\n",
    "a\n",
    "b\n",
    "\n",
    "Sample Output 1:\n",
    "\n",
    "1\n",
    "\n",
    "Sample Input 2:\n",
    "\n",
    "ababa\n",
    "b\n",
    "a\n",
    "\n",
    "Sample Output 2:\n",
    "\n",
    "1\n",
    "\n",
    "Sample Input 3:\n",
    "\n",
    "ababa\n",
    "c\n",
    "c\n",
    "\n",
    "Sample Output 3:\n",
    "\n",
    "0\n",
    "\n",
    "Sample Input 4:\n",
    "\n",
    "ababac\n",
    "c\n",
    "c\n",
    "\n",
    "Sample Output 4:\n",
    "\n",
    "Impossible\n",
    "\n",
    "\n",
    "'''\n",
    "\n",
    "string = 'ababac'\n",
    "old_replaced = 'a'\n",
    "new_replaced = 'b'\n",
    "\n",
    "\n",
    "#string, old_replaced, new_replaced = input(), input(), input()\n",
    "\n",
    "i = 0\n",
    "while i != 1000:\n",
    "    if string.count(old_replaced) != 0:\n",
    "        string = string.replace(old_replaced, new_replaced)\n",
    "        i += 1\n",
    "    else:\n",
    "        print(i)\n",
    "        break\n",
    "else:\n",
    "    print('Impossible')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Raw Cell Format",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
